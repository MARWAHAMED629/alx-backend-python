#!/bin/bash

# Blue-Green Deployment Automation Script for Django Messaging App
# This script automates the entire blue-green deployment workflow including:
# - Deploying the new (green) version alongside the current (blue) version
# - Performing health checks on deployments and services
# - Switching user traffic between blue and green versions seamlessly
# - Supporting rollback to the previous stable version if needed
# - Ensuring zero downtime during deployment
# - Providing utilities for logs inspection and performance testing

set -e  # Exit immediately if any command fails

# Define color codes for pretty output formatting
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color (reset)

# Configuration variables (can be overridden by environment variables)
NAMESPACE=${NAMESPACE:-default}
APP_NAME="django-messaging-app"
SERVICE_NAME="django-messaging-service"
GREEN_TEST_SERVICE="django-messaging-service-green-test"
BLUE_SERVICE="django-messaging-service-blue"
HEALTH_CHECK_PATH="/admin/"
TIMEOUT=300           # Max wait time in seconds for deployments to be ready
CHECK_INTERVAL=10     # Interval in seconds between readiness checks

# Functions to print colored output messages
print_status() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Verify that required command-line tools are installed
check_command() {
    if ! command -v "$1" &> /dev/null; then
        print_error "Command '$1' not found. Please install it before proceeding."
        exit 1
    fi
}

# Wait until a Kubernetes deployment has all desired replicas ready or timeout occurs
wait_for_deployment() {
    local deployment_name=$1
    local timeout=$2
    local elapsed=0

    print_status "Waiting for deployment '$deployment_name' to reach ready state..."

    while [ $elapsed -lt $timeout ]; do
        if kubectl get deployment "$deployment_name" -n "$NAMESPACE" &> /dev/null; then
            local ready=$(kubectl get deployment "$deployment_name" -n "$NAMESPACE" -o jsonpath='{.status.readyReplicas}')
            local desired=$(kubectl get deployment "$deployment_name" -n "$NAMESPACE" -o jsonpath='{.spec.replicas}')
            if [ "$ready" = "$desired" ] && [ "$ready" != "0" ]; then
                print_success "Deployment '$deployment_name' is ready ($ready/$desired pods)."
                return 0
            fi
        fi
        sleep $CHECK_INTERVAL
        elapsed=$((elapsed + CHECK_INTERVAL))
        print_status "Still waiting... ($elapsed/${timeout}s elapsed)"
    done

    print_error "Timed out waiting for deployment '$deployment_name' to become ready."
    return 1
}

# Perform HTTP health check against the given service
health_check() {
    local service_name=$1
    local max_attempts=${2:-6}
    local attempt=1

    print_status "Starting health check on service '$service_name'..."

    local service_ip=$(kubectl get service "$service_name" -n "$NAMESPACE" -o jsonpath='{.spec.clusterIP}' 2>/dev/null)
    if [ -z "$service_ip" ]; then
        print_error "Unable to retrieve IP address for service '$service_name'."
        return 1
    fi

    while [ $attempt -le $max_attempts ]; do
        print_status "Health check attempt $attempt of $max_attempts on '$service_name' ($service_ip)..."
        if kubectl run health-check-$RANDOM --image=curlimages/curl --rm -i --restart=Never --timeout=30s \
           -- curl -s -f "http://$service_ip$HEALTH_CHECK_PATH" > /dev/null 2>&1; then
            print_success "Health check succeeded for service '$service_name'."
            return 0
        fi
        sleep 10
        attempt=$((attempt + 1))
    done

    print_error "Health check failed for service '$service_name' after $max_attempts attempts."
    return 1
}

# Retrieve currently active deployment version based on service selector labels
get_current_version() {
    kubectl get service "$SERVICE_NAME" -n "$NAMESPACE" -o jsonpath='{.spec.selector.version}' 2>/dev/null || echo "unknown"
}

# Switch user traffic to the specified deployment version by updating the service selector
switch_traffic() {
    local target_version=$1
    print_status "Switching traffic to '$target_version' deployment..."

    kubectl patch service "$SERVICE_NAME" -n "$NAMESPACE" -p "{\"spec\":{\"selector\":{\"app\":\"$APP_NAME\",\"version\":\"$target_version\"}}}"
    kubectl annotate service "$SERVICE_NAME" -n "$NAMESPACE" "current.version=$target_version" --overwrite

    sleep 5 # Brief pause to allow service update to propagate
    print_success "Traffic successfully switched to '$target_version' deployment."
}

# Display status of current deployments, pods, and services related to the application
show_status() {
    print_status "Displaying current deployment status..."
    echo

    local current_version=$(get_current_version)
    print_status "Active deployment version: $current_version"
    echo

    kubectl get deployments -l app="$APP_NAME" -n "$NAMESPACE" -o wide 2>/dev/null || true
    echo
    kubectl get pods -l app="$APP_NAME" -n "$NAMESPACE" -o wide 2>/dev/null || true
    echo
    kubectl get services -l app="$APP_NAME" -n "$NAMESPACE" -o wide 2>/dev/null || true
}

# Deploy the green version and verify readiness and health before switching traffic
deploy_green() {
    print_status "Starting deployment of the green version..."

    if [ -f "green_deployment.yaml" ]; then
        kubectl apply -f green_deployment.yaml -n "$NAMESPACE"

        if wait_for_deployment "$APP_NAME-green" $TIMEOUT; then
            print_success "Green deployment is ready."

            if [ -f "kubeservice.yaml" ]; then
                kubectl apply -f kubeservice.yaml -n "$NAMESPACE"
                sleep 10 # Wait for services to become available

                if health_check "$GREEN_TEST_SERVICE"; then
                    print_success "Green deployment passed health checks."
                    return 0
                else
                    print_error "Green deployment failed health checks."
                    return 1
                fi
            else
                print_warning "Service definition file 'kubeservice.yaml' not found; skipping service creation."
                return 1
            fi
        else
            print_error "Green deployment did not become ready in time."
            return 1
        fi
    else
        print_error "Deployment manifest 'green_deployment.yaml' not found."
        return 1
    fi
}

# Clean up old deployment by scaling down and deleting its resources
cleanup_old_version() {
    local version_to_cleanup=$1
    print_warning "Cleaning up deployment version '$version_to_cleanup'..."

    kubectl scale deployment "$APP_NAME-$version_to_cleanup" -n "$NAMESPACE" --replicas=0 2>/dev/null || true
    sleep 30
    kubectl delete deployment "$APP_NAME-$version_to_cleanup" -n "$NAMESPACE" --ignore-not-found=true

    print_success "Cleanup of deployment version '$version_to_cleanup' completed."
}

# Rollback to the previously active deployment version in case of issues
rollback() {
    local current_version=$(get_current_version)
    local rollback_version

    if [ "$current_version" = "green" ]; then
        rollback_version="blue"
    else
        rollback_version="green"
    fi

    print_warning "Initiating rollback from '$current_version' to '$rollback_version'..."

    if kubectl get deployment "$APP_NAME-$rollback_version" -n "$NAMESPACE" &> /dev/null; then
        kubectl scale deployment "$APP_NAME-$rollback_version" -n "$NAMESPACE" --replicas=3

        if wait_for_deployment "$APP_NAME-$rollback_version" 120; then
            switch_traffic "$rollback_version"
            print_success "Rollback to '$rollback_version' completed successfully."
        else
            print_error "Rollback failed: Deployment '$rollback_version' is not ready."
            return 1
        fi
    else
        print_error "Rollback failed: Deployment '$rollback_version' does not exist."
        return 1
    fi
}

# Fetch and display logs from pods of a specified deployment version
check_logs() {
    local version=${1:-$(get_current_version)}
    local lines=${2:-50}

    print_status "Retrieving last $lines lines of logs for deployment version '$version'..."

    local pods=$(kubectl get pods -l "app=$APP_NAME,version=$version" -n "$NAMESPACE" -o jsonpath='{.items[*].metadata.name}' 2>/dev/null)

    if [ -z "$pods" ]; then
        print_warning "No pods found for deployment version '$version'."
        return 1
    fi

    for pod in $pods; do
        echo
        print_status "Logs from pod '$pod':"
        kubectl logs "$pod" -n "$NAMESPACE" --tail="$lines" 2>/dev/null || print_warning "Unable to retrieve logs for pod '$pod'."
    done
}

# Perform a load/performance test against the active service
performance_test() {
    local duration=${1:-30}
    local connections=${2:-10}

    print_status "Executing performance test for $duration seconds with $connections concurrent connections..."

    local service_ip=$(kubectl get service "$SERVICE_NAME" -n "$NAMESPACE" -o jsonpath='{.spec.clusterIP}')

    if [ -z "$service_ip" ]; then
        print_error "Failed to retrieve service IP."
        return 1
    fi

    if command -v wrk &> /dev/null; then
        kubectl run perf-test-$RANDOM --image=williamyeh/wrk --rm -i --restart=Never --timeout=60s \
            -- -t4 -c"$connections" -d"${duration}s" "http://$service_ip$HEALTH_CHECK_PATH"
    else
        print_status "Running basic load test using curl in a loop..."
        kubectl run curl-test-$RANDOM --image=curlimages/curl --rm -i --restart=Never --timeout=60s \
            -- sh -c "for i in \$(seq 1 20); do curl -s http://$service_ip$HEALTH_CHECK_PATH > /dev/null && echo 'Request \$i: OK' || echo 'Request \$i: FAILED'; sleep 1; done"
    fi
}

# Display usage instructions
usage() {
    echo "Usage: $0 {deploy|switch|rollback|status|logs|test|cleanup|health-check} [options]"
    echo
    echo "Commands:"
    echo "  deploy           Deploy green version and switch traffic if healthy"
    echo "  switch <version> Switch traffic to specified version (blue or green)"
    echo "  rollback         Rollback to the previous deployment version"
    echo "  status           Show current deployment status"
    echo "  logs [version] [lines] Show logs for specified version (default: current, 50 lines)"
    echo "  test [duration] [connections] Run performance test (defaults: 30s, 10 connections)"
    echo "  cleanup <version> Cleanup specified deployment version (blue or green)"
    echo "  health-check [service] Run health check on specified service (default: active service)"
    echo
    echo "Examples:"
    echo "  $0 deploy"
    echo "  $0 switch green"
    echo "  $0 logs blue 100"
    echo "  $0 test 60 20"
}

# Main entry point for the script
main() {
    check_command kubectl

    local command=${1:-status}

    case $command in
        deploy)
            print_status "Initiating blue-green deployment..."
            show_status

            if deploy_green; then
                print_status "Green deployment successful. Switching traffic..."
                switch_traffic "green"

                sleep 10
                if health_check "$SERVICE_NAME"; then
                    print_success "Blue-green deployment completed successfully."
                    show_status
                    echo
                    print_warning "Green is now active. You may cleanup the blue deployment using:"
                    print_warning "$0 cleanup blue"
                else
                    print_error "Health check after switching failed. Rolling back..."
                    rollback
                fi
            else
                print_error "Green deployment failed."
                exit 1
            fi
            ;;
        switch)
            local version=${2}
            if [ -z "$version" ]; then
                print_error "Version (blue or green) must be specified."
                usage
                exit 1
            fi
            switch_traffic "$version"
            sleep 10
            health_check "$SERVICE_NAME"
            show_status
            ;;
        rollback)
            rollback
            ;;
        status)
            show_status
            ;;
        logs)
            check_logs "$2" "$3"
            ;;
        test)
            performance_test "$2" "$3"
            ;;
        cleanup)
            local version=${2}
            if [ -z "$version" ]; then
                print_error "Version to cleanup must be specified (blue or green)."
                exit 1
            fi
            cleanup_old_version "$version"
            ;;
        health-check)
            local service=${2:-$SERVICE_NAME}
            health_check "$service"
            ;;
        *)
            usage
            exit 1
            ;;
    esac
}

# Run main with all passed arguments
main "$@"